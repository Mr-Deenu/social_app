{% extends "base.html" %}
{% load static %}
{% block content %}

<!-- âœ… Header: DP + username clickable -->
<div class="d-flex align-items-center justify-content-between bg-white border rounded px-3 py-2 mb-2">
  <div class="d-flex align-items-center gap-2">
    {% if other_user.profile.image %}
      <img src="{{ other_user.profile.image.url }}" class="rounded-circle" width="36" height="36" style="object-fit:cover;">
    {% else %}
      <img src="{% static 'images/default.png' %}" class="rounded-circle" width="36" height="36" style="object-fit:cover;">
    {% endif %}

    <a href="{% url 'profile' other_user.username %}" class="text-decoration-none text-dark">
      <b>{{ other_user.username }}</b>
    </a>

    <span class="text-muted small" id="typingBox" style="display:none;">typing...</span>
  </div>
</div>

<!-- âœ… Chat Box -->
<div class="card p-3 mb-2" id="chatBox" style="height:60vh; overflow-y:auto;">
  <div id="messagesArea" class="d-flex flex-column gap-2"></div>
</div>

<!-- âœ… Send form (text + file) -->
<form method="POST" class="d-flex gap-2 align-items-center" enctype="multipart/form-data" autocomplete="off">
  {% csrf_token %}

  <label class="btn btn-outline-secondary mb-0" title="Send Photo/Video">
    ðŸ“Ž
    <input type="file" name="attachment" id="fileInput" hidden accept="image/*,video/*">
  </label>

  <input id="msgInput" name="text" class="form-control" placeholder="Type message...">
  <button class="btn btn-primary">Send</button>
</form>

<!-- âœ… Right-click / Long press Menu -->
<div id="ctxMenu"
     style="display:none; position:fixed; z-index:9999; background:white; border:1px solid #ddd; border-radius:8px; padding:8px; min-width:160px;">
  <button id="deleteBtn" class="btn btn-sm btn-danger w-100">Delete</button>
</div>

<script>
const convoId = "{{ convo.id }}";
const me = "{{ request.user.username }}";

const chatBox = document.getElementById("chatBox");
const messagesArea = document.getElementById("messagesArea");
const typingBox = document.getElementById("typingBox");
const msgInput = document.getElementById("msgInput");

const ctxMenu = document.getElementById("ctxMenu");
const deleteBtn = document.getElementById("deleteBtn");

let selectedMsgId = null;

// âœ… cookie csrf
function getCookie(name) {
  let cookieValue = null;
  if (document.cookie && document.cookie !== "") {
    const cookies = document.cookie.split(";");
    for (let c of cookies) {
      c = c.trim();
      if (c.startsWith(name + "=")) {
        cookieValue = decodeURIComponent(c.substring(name.length + 1));
        break;
      }
    }
  }
  return cookieValue;
}
const csrftoken = getCookie("csrftoken");

// âœ… Only autoscroll if user is already near bottom
function isNearBottom() {
  return (chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight) < 120;
}
function scrollBottom() {
  chatBox.scrollTop = chatBox.scrollHeight;
}

// âœ… show/hide menu
function showMenu(x, y, msgId, canDelete) {
  selectedMsgId = msgId;
  deleteBtn.style.display = canDelete ? "block" : "none";
  ctxMenu.style.left = x + "px";
  ctxMenu.style.top = y + "px";
  ctxMenu.style.display = "block";
}
function hideMenu() {
  ctxMenu.style.display = "none";
  selectedMsgId = null;
}

// âœ… click outside -> hide (but menu click shouldn't close immediately)
document.addEventListener("click", (e) => {
  if (!ctxMenu.contains(e.target)) hideMenu();
});
document.addEventListener("scroll", hideMenu, true);

// âœ… delete (AJAX)
deleteBtn.addEventListener("click", async (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (!selectedMsgId) return;

  if (!confirm("Delete this message?")) return;

  await fetch(`/chat/delete/${selectedMsgId}/`, {
    method: "POST",
    headers: {
      "X-CSRFToken": csrftoken,
      "X-Requested-With": "XMLHttpRequest"
    }
  });

  hideMenu();
  fetchMessages(true);
});

function escapeHtml(str){
  return (str || "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;");
}

/* -------------------------------------------------------
   âœ… FIX: video reload à¤°à¥‹à¤•à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤:
   - UI rerender ONLY when new message arrives
   - Seen update only text change (no rerender)
-------------------------------------------------------- */
let lastRenderKey = "";

function updateSeenOnly(list){
  // last my message
  let lastMine = null;
  for (let i = list.length - 1; i >= 0; i--) {
    if (list[i].sender === me) { lastMine = list[i]; break; }
  }
  if (!lastMine) return;

  const box = document.getElementById("seen-" + lastMine.id);
  if (box) box.innerText = lastMine.is_read ? "Seen âœ…" : "Sent âœ“";
}

function renderMessages(list, forceScroll=false) {
  const shouldScroll = forceScroll || isNearBottom();

  let html = "";
  let lastMineId = null;

  for (const m of list) {
    const isMine = (m.sender === me);
    if (isMine) lastMineId = m.id;

    html += `
      <div class="d-flex ${isMine ? "justify-content-end" : "justify-content-start"}">
        <div class="p-2 rounded ${isMine ? "bg-primary text-white" : "bg-light"}"
             style="max-width:70%;"
             data-msgid="${m.id}"
             data-candelete="${isMine ? "1" : "0"}">
          <div class="small ${isMine ? "text-white-50" : "text-muted"}">
            <b>${escapeHtml(m.sender)}</b> â€¢ ${escapeHtml(m.created)}
          </div>
    `;

    // âœ… attachment
    if (m.attachment) {
      if (m.attachment_type === "image") {
        html += `<img src="${m.attachment}" class="img-fluid rounded mt-2" style="max-height:260px; object-fit:cover;">`;
      } else if (m.attachment_type === "video") {
        html += `
          <video class="w-100 rounded mt-2" controls preload="metadata" playsinline style="max-height:260px;">
            <source src="${m.attachment}">
            Your browser does not support the video tag.
          </video>
        `;
      } else {
        html += `<a href="${m.attachment}" class="d-block mt-2 text-decoration-none ${isMine ? "text-white" : ""}">Download file</a>`;
      }
    }

    // âœ… shared post
    if (m.shared_post) {
      html += `
        <div class="border rounded p-2 mt-2 bg-white text-dark">
          <b>${escapeHtml(m.shared_post.author)}</b>
          ${m.shared_post.image ? `<img src="${m.shared_post.image}" class="img-fluid rounded mt-2" style="max-height:220px; object-fit:cover;">` : ""}
          <div class="mt-1">${escapeHtml(m.shared_post.content)}</div>
          <a href="/post/${m.shared_post.id}/" class="small text-decoration-none">View Post â†’</a>
        </div>
      `;
    }

    // âœ… normal text
    if (m.text) {
      html += `<div class="mt-2">${escapeHtml(m.text)}</div>`;
    }

    // âœ… Seen only for my messages (text updated later)
    if (isMine) {
      html += `<div class="small text-end text-white-50" id="seen-${m.id}"></div>`;
    }

    html += `</div></div>`;
  }

  messagesArea.innerHTML = html;

  // âœ… attach right-click / long-press handlers
  document.querySelectorAll("[data-msgid]").forEach(el => {
    const msgId = el.getAttribute("data-msgid");
    const canDelete = el.getAttribute("data-candelete") === "1";

    el.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      showMenu(e.clientX, e.clientY, msgId, canDelete);
    });

    let pressTimer = null;
    el.addEventListener("touchstart", (e) => {
      pressTimer = setTimeout(() => {
        const t = e.touches[0];
        showMenu(t.clientX, t.clientY, msgId, canDelete);
      }, 500);
    });
    el.addEventListener("touchend", ()=> clearTimeout(pressTimer));
    el.addEventListener("touchmove", ()=> clearTimeout(pressTimer));
  });

  // âœ… set seen on last mine
  if (lastMineId) {
    const lastMsg = list.find(x => x.id === lastMineId);
    const box = document.getElementById("seen-" + lastMineId);
    if (box) box.innerText = lastMsg.is_read ? "Seen âœ…" : "Sent âœ“";
  }

  if (shouldScroll) scrollBottom();
}

async function fetchMessages(force=false) {
  try {
    const res = await fetch(`/chat/api/messages/${convoId}/`);
    const data = await res.json();
    const list = data.messages || [];

    const lastId = list.length ? list[list.length - 1].id : 0;
    const key = list.length + ":" + lastId;

    // âœ… only rerender when new msg comes (stops video reload)
    if (force || key !== lastRenderKey) {
      lastRenderKey = key;
      renderMessages(list, force);
    } else {
      updateSeenOnly(list);
    }
  } catch (e) {
    // if api fails, show small message
    messagesArea.innerHTML = `<div class="text-danger small">Failed to load messages. Refresh page.</div>`;
  }
}

async function checkTyping() {
  const res = await fetch(`/chat/api/typing/${convoId}/`);
  const data = await res.json();
  typingBox.style.display = data.typing ? "inline" : "none";
}

msgInput.addEventListener("input", () => {
  fetch(`/chat/api/typing/${convoId}/set/`);
});

// âœ… start
fetchMessages(true);
checkTyping();

// âœ… polling
setInterval(fetchMessages, 2500);
setInterval(checkTyping, 1500);
</script>

{% endblock %}
